//go:build ignore

// rr_generate generates zpack.go which houses 2 large unpack/pack functions.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"html/template"
	"log"
	"os"

	"github.com/miekg/dnsv2/internal/generate"
)

var hdr = `
// Code generated by "go run pack_generate.go"; DO NOT EDIT.

package dns

import (
	"fmt"
)

`

var packFunc = template.Must(template.New("packFunc").Parse(`
func pack(rr RR, msg []byte, off int, compression map[string]uint16) (uint16, error) {
	switch x := rr.(type) {
{{range .}}{{if ne . "RFC3597"}}  case *{{.}}:
	return x.pack(msg, off, compression)
{{end}}{{end}} }
	// if here, we don't have the RR in our pkg, check if it does Packer.
	if x, ok := rr.(Packer); ok {
		return x.Pack(msg, off)
	}
    return 0, fmt.Errorf("no pack defined")
}

`))

var unpackFunc = template.Must(template.New("unpackFunc").Parse(`
func unpack(rr RR, data, msgBuf []byte) error {
	switch x := rr.(type) {
{{range .}}{{if ne . "RFC3597"}}  case *{{.}}:
	return x.unpack(data, msgBuf)
{{end}}{{end}} }
	// if here, we don't have the RR in our pkg, check if it does Packer.
	if x, ok := rr.(Packer); ok {
		return x.Unpack(data)
	}
    return 0, fmt.Errorf("no unpack defined")
}

`))

const out = "zpack.go"

func main() {
	flag.Parse()
	types, err := generate.Types("types.go")
	if err != nil {
		log.Fatalf("Failed to generate %s: %v", out, err)
	}

	source := &bytes.Buffer{}
	source.WriteString(hdr)

	if err := packFunc.Execute(source, types); err != nil {
		log.Fatalf("Failed to generate %s: %v", out, err)
	}

	if err := unpackFunc.Execute(source, types); err != nil {
		log.Fatalf("Failed to generate %s: %v", out, err)
	}

	formatted, err := format.Source(source.Bytes())
	if err != nil {
		source.WriteTo(os.Stderr)
		log.Fatalf("Failed to generate %s: %v", out, err)
	}

	if *generate.FlagDebug {
		fmt.Print(string(formatted))
		return
	}

	if err := os.WriteFile(out, formatted, 0640); err != nil {
		log.Fatalf("Failed to generate %s: %v", out, err)
	}
}
