//go:build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"log"
	"slices"
	"strings"

	"github.com/miekg/dnsv2/internal/generate"
)

var skipLen = []string{"NSEC", "NSEC3", "OPT", "CSYNC", "APLPrefix"}

var hdr = `
// Code generated by "go run len_generate.go"; DO NOT EDIT.

package dns

import (
	"encoding/base64"
	"net"
)

`

const out = "zlen.go"

func main() {
	flag.Parse()
	specs, err := generate.StructTypeSpecs("types.go")
	if err != nil {
		log.Fatalf("Failed to generate %s: %v", out, err)
	}
	b := &bytes.Buffer{}
	b.WriteString(hdr)

	for _, spec := range specs {
		rrname := spec.Name.Name
		if slices.Contains(skipLen, rrname) {
			continue
		}

		fmt.Fprintf(b, "func (rr *%s) Len() int {\n", rrname)
		fmt.Fprintf(b, "l := rr.Hdr.Len()\n")

		strct := spec.Type.(*ast.StructType)
		for _, field := range strct.Fields.List {
			if len(field.Names) == 0 {
				continue
			}

			fieldname := field.Names[0].String()
			if fieldname == "Hdr" {
				continue
			}

			// fieldtype is either slice or the actual singular type name.
			fieldtype := ""
			if id, ok := field.Type.(*ast.Ident); ok {
				fieldtype = id.Name
			}
			if _, ok := field.Type.(*ast.ArrayType); ok {
				fieldtype = "slice"
			}

			tag := ""
			if field.Tag != nil {
				tag = strings.Trim(field.Tag.Value, "`")
			}

			o := func(s string) { fmt.Fprintf(b, s, fieldname) }

			if fieldtype == "slice" {
				switch tag {
				case `dns:"-"`:
					// ignored
				case `dns:"cdomain-name"`:
					o("for _, x := range rr.%s { l += len(x) }\n")
				case `dns:"domain-name"`:
					o("for _, x := range rr.%s { l += len(x) }\n")
				case `dns:"txt"`:
					o("for _, x := range rr.%s { l += len(x) + 1 }\n")
				case `dns:"apl"`:
					o("for _, x := range rr.%s { l += x.len() }\n")
				case `dns:"pairs"`:
					o("for _, x := range rr.%s { l += 4 + int(x.len()) }\n")
				default:
					log.Fatalln(rrname, fieldname, tag)
				}
				continue
			}

			switch {
			case tag == `dns:"-"`:
				// ignored
			case tag == `dns:"cdomain-name"`:
				o("l += len(rr.%s)\n")
			case tag == `dns:"domain-name"`:
				o("l += len(rr.%s)\n")
			case tag == `dns:"octet"`:
				o("l += len(rr.%s)\n")
			case strings.HasPrefix(tag, `dns:"size-base64`):
				fallthrough
			case tag == `dns:"base64"`:
				o("l += base64.StdEncoding.DecodedLen(len(rr.%s))\n")
			case strings.HasPrefix(tag, `dns:"size-hex:`): // this has an extra field where the length is stored
				o("l += len(rr.%s)/2\n")
			case tag == `dns:"hex"`:
				o("l += len(rr.%s)/2\n")
			case tag == `dns:"any"`:
				o("l += len(rr.%s)\n")
			case tag == `dns:"a"`:
				o("if len(rr.%s) != 0 { l += net.IPv4len }\n")
			case tag == `dns:"aaaa"`:
				o("if len(rr.%s) != 0 { l += net.IPv6len }\n")
			case tag == `dns:"txt"`:
				o("for _, t := range rr.%s { l += len(t) + 1 }\n")
			case tag == `dns:"uint48"`:
				o("l += 6 // %s\n")
			case tag == `dns:"ipsechost"`:
				o(`switch rr.GatewayType {
				case IPSECGatewayIPv4:
					l += net.IPv4len
				case IPSECGatewayIPv6:
					l += net.IPv6len
				case IPSECGatewayHost:
					l += len(rr.%s) + 1
				}
				`)
			case tag == `dns:"amtrelayhost"`:
				o(`switch rr.GatewayType {
				case AMTRELAYIPv4:
					l += net.IPv4len
				case AMTRELAYIPv6:
					l += net.IPv6len
				case AMTRELAYHost:
					l += len(rr.%s) + 1
				}
				`)
			case tag == `dns:"amtrelaytype"`:
				o("l++ // %s\n")
			case tag == "":
				switch fieldtype {
				case "uint8":
					o("l++ // %s\n")
				case "uint16":
					o("l += 2 // %s\n")
				case "uint32":
					o("l += 4 // %s\n")
				case "uint64":
					o("l += 8 // %s\n")
				case "string":
					o("l += len(rr.%s) + 1\n")
				default:
					log.Fatalln(rrname, fieldname)
				}
			default:
				log.Fatalln(rrname, fieldname, tag)
			}
		}
		fmt.Fprint(b, "return l }\n\n")
	}

	generate.Write(b, out)
}
