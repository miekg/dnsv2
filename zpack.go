// Code generated by "go run pack_generate.go"; DO NOT EDIT.

package dns

import (
	"fmt"
)

func pack(rr RR, msg []byte, off int, compression map[string]uint16) (int, error) {
	switch x := rr.(type) {
	case *ANY:
		return x.pack(msg, off, compression)
	case *NULL:
		return x.pack(msg, off, compression)
	case *CNAME:
		return x.pack(msg, off, compression)
	case *HINFO:
		return x.pack(msg, off, compression)
	case *MB:
		return x.pack(msg, off, compression)
	case *MG:
		return x.pack(msg, off, compression)
	case *MINFO:
		return x.pack(msg, off, compression)
	case *MR:
		return x.pack(msg, off, compression)
	case *MF:
		return x.pack(msg, off, compression)
	case *MD:
		return x.pack(msg, off, compression)
	case *MX:
		return x.pack(msg, off, compression)
	case *AFSDB:
		return x.pack(msg, off, compression)
	case *X25:
		return x.pack(msg, off, compression)
	case *RT:
		return x.pack(msg, off, compression)
	case *NS:
		return x.pack(msg, off, compression)
	case *PTR:
		return x.pack(msg, off, compression)
	case *RP:
		return x.pack(msg, off, compression)
	case *SOA:
		return x.pack(msg, off, compression)
	case *TXT:
		return x.pack(msg, off, compression)
	case *SPF:
		return x.pack(msg, off, compression)
	case *AVC:
		return x.pack(msg, off, compression)
	case *SRV:
		return x.pack(msg, off, compression)
	case *NAPTR:
		return x.pack(msg, off, compression)
	case *CERT:
		return x.pack(msg, off, compression)
	case *DNAME:
		return x.pack(msg, off, compression)
	case *A:
		return x.pack(msg, off, compression)
	case *AAAA:
		return x.pack(msg, off, compression)
	case *PX:
		return x.pack(msg, off, compression)
	case *GPOS:
		return x.pack(msg, off, compression)
	case *LOC:
		return x.pack(msg, off, compression)
	case *SIG:
		return x.pack(msg, off, compression)
	case *RRSIG:
		return x.pack(msg, off, compression)
	case *NSEC:
		return x.pack(msg, off, compression)
	case *DLV:
		return x.pack(msg, off, compression)
	case *CDS:
		return x.pack(msg, off, compression)
	case *DS:
		return x.pack(msg, off, compression)
	case *KX:
		return x.pack(msg, off, compression)
	case *TA:
		return x.pack(msg, off, compression)
	case *TALINK:
		return x.pack(msg, off, compression)
	case *SSHFP:
		return x.pack(msg, off, compression)
	case *KEY:
		return x.pack(msg, off, compression)
	case *CDNSKEY:
		return x.pack(msg, off, compression)
	case *DNSKEY:
		return x.pack(msg, off, compression)
	case *IPSECKEY:
		return x.pack(msg, off, compression)
	case *AMTRELAY:
		return x.pack(msg, off, compression)
	case *RKEY:
		return x.pack(msg, off, compression)
	case *NSAPPTR:
		return x.pack(msg, off, compression)
	case *NSEC3:
		return x.pack(msg, off, compression)
	case *NSEC3PARAM:
		return x.pack(msg, off, compression)
	case *TKEY:
		return x.pack(msg, off, compression)
	case *URI:
		return x.pack(msg, off, compression)
	case *DHCID:
		return x.pack(msg, off, compression)
	case *TLSA:
		return x.pack(msg, off, compression)
	case *SMIMEA:
		return x.pack(msg, off, compression)
	case *HIP:
		return x.pack(msg, off, compression)
	case *NINFO:
		return x.pack(msg, off, compression)
	case *NID:
		return x.pack(msg, off, compression)
	case *L32:
		return x.pack(msg, off, compression)
	case *L64:
		return x.pack(msg, off, compression)
	case *LP:
		return x.pack(msg, off, compression)
	case *EUI48:
		return x.pack(msg, off, compression)
	case *EUI64:
		return x.pack(msg, off, compression)
	case *CAA:
		return x.pack(msg, off, compression)
	case *UID:
		return x.pack(msg, off, compression)
	case *GID:
		return x.pack(msg, off, compression)
	case *UINFO:
		return x.pack(msg, off, compression)
	case *EID:
		return x.pack(msg, off, compression)
	case *NIMLOC:
		return x.pack(msg, off, compression)
	case *OPENPGPKEY:
		return x.pack(msg, off, compression)
	case *CSYNC:
		return x.pack(msg, off, compression)
	case *ZONEMD:
		return x.pack(msg, off, compression)
	case *OPT:
		return x.pack(msg, off, compression)
	case *APL:
		return x.pack(msg, off, compression)
	}
	// if here, we don't have the RR in our pkg, check if it does Packer.
	if x, ok := rr.(Packer); ok {
		return x.Pack(msg, off)
	}
	return 0, fmt.Errorf("no pack defined")
}

func unpack(rr RR, data, msgBuf []byte) error {
	switch x := rr.(type) {
	case *ANY:
		return x.unpack(data, msgBuf)
	case *NULL:
		return x.unpack(data, msgBuf)
	case *CNAME:
		return x.unpack(data, msgBuf)
	case *HINFO:
		return x.unpack(data, msgBuf)
	case *MB:
		return x.unpack(data, msgBuf)
	case *MG:
		return x.unpack(data, msgBuf)
	case *MINFO:
		return x.unpack(data, msgBuf)
	case *MR:
		return x.unpack(data, msgBuf)
	case *MF:
		return x.unpack(data, msgBuf)
	case *MD:
		return x.unpack(data, msgBuf)
	case *MX:
		return x.unpack(data, msgBuf)
	case *AFSDB:
		return x.unpack(data, msgBuf)
	case *X25:
		return x.unpack(data, msgBuf)
	case *RT:
		return x.unpack(data, msgBuf)
	case *NS:
		return x.unpack(data, msgBuf)
	case *PTR:
		return x.unpack(data, msgBuf)
	case *RP:
		return x.unpack(data, msgBuf)
	case *SOA:
		return x.unpack(data, msgBuf)
	case *TXT:
		return x.unpack(data, msgBuf)
	case *SPF:
		return x.unpack(data, msgBuf)
	case *AVC:
		return x.unpack(data, msgBuf)
	case *SRV:
		return x.unpack(data, msgBuf)
	case *NAPTR:
		return x.unpack(data, msgBuf)
	case *CERT:
		return x.unpack(data, msgBuf)
	case *DNAME:
		return x.unpack(data, msgBuf)
	case *A:
		return x.unpack(data, msgBuf)
	case *AAAA:
		return x.unpack(data, msgBuf)
	case *PX:
		return x.unpack(data, msgBuf)
	case *GPOS:
		return x.unpack(data, msgBuf)
	case *LOC:
		return x.unpack(data, msgBuf)
	case *SIG:
		return x.unpack(data, msgBuf)
	case *RRSIG:
		return x.unpack(data, msgBuf)
	case *NSEC:
		return x.unpack(data, msgBuf)
	case *DLV:
		return x.unpack(data, msgBuf)
	case *CDS:
		return x.unpack(data, msgBuf)
	case *DS:
		return x.unpack(data, msgBuf)
	case *KX:
		return x.unpack(data, msgBuf)
	case *TA:
		return x.unpack(data, msgBuf)
	case *TALINK:
		return x.unpack(data, msgBuf)
	case *SSHFP:
		return x.unpack(data, msgBuf)
	case *KEY:
		return x.unpack(data, msgBuf)
	case *CDNSKEY:
		return x.unpack(data, msgBuf)
	case *DNSKEY:
		return x.unpack(data, msgBuf)
	case *IPSECKEY:
		return x.unpack(data, msgBuf)
	case *AMTRELAY:
		return x.unpack(data, msgBuf)
	case *RKEY:
		return x.unpack(data, msgBuf)
	case *NSAPPTR:
		return x.unpack(data, msgBuf)
	case *NSEC3:
		return x.unpack(data, msgBuf)
	case *NSEC3PARAM:
		return x.unpack(data, msgBuf)
	case *TKEY:
		return x.unpack(data, msgBuf)
	case *URI:
		return x.unpack(data, msgBuf)
	case *DHCID:
		return x.unpack(data, msgBuf)
	case *TLSA:
		return x.unpack(data, msgBuf)
	case *SMIMEA:
		return x.unpack(data, msgBuf)
	case *HIP:
		return x.unpack(data, msgBuf)
	case *NINFO:
		return x.unpack(data, msgBuf)
	case *NID:
		return x.unpack(data, msgBuf)
	case *L32:
		return x.unpack(data, msgBuf)
	case *L64:
		return x.unpack(data, msgBuf)
	case *LP:
		return x.unpack(data, msgBuf)
	case *EUI48:
		return x.unpack(data, msgBuf)
	case *EUI64:
		return x.unpack(data, msgBuf)
	case *CAA:
		return x.unpack(data, msgBuf)
	case *UID:
		return x.unpack(data, msgBuf)
	case *GID:
		return x.unpack(data, msgBuf)
	case *UINFO:
		return x.unpack(data, msgBuf)
	case *EID:
		return x.unpack(data, msgBuf)
	case *NIMLOC:
		return x.unpack(data, msgBuf)
	case *OPENPGPKEY:
		return x.unpack(data, msgBuf)
	case *CSYNC:
		return x.unpack(data, msgBuf)
	case *ZONEMD:
		return x.unpack(data, msgBuf)
	case *OPT:
		return x.unpack(data, msgBuf)
	case *APL:
		return x.unpack(data, msgBuf)
	}
	// if here, we don't have the RR in our pkg, check if it does Packer.
	if x, ok := rr.(Packer); ok {
		return x.Unpack(data)
	}
	return fmt.Errorf("no unpack defined")
}
