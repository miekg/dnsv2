// Code generated by "go run types_generate.go"; DO NOT EDIT.

package dns

/*
// copy() functions
func (rr *A) copy() RR {
	return &A{rr.Hdr, cloneSlice(rr.A)}
}

func (rr *AAAA) copy() RR {
	return &AAAA{rr.Hdr, cloneSlice(rr.AAAA)}
}

func (rr *AFSDB) copy() RR {
	return &AFSDB{rr.Hdr, rr.Subtype, rr.Hostname}
}

func (rr *AMTRELAY) copy() RR {
	return &AMTRELAY{
		rr.Hdr,
		rr.Precedence,
		rr.GatewayType,
		cloneSlice(rr.GatewayAddr),
		rr.GatewayHost,
	}
}

func (rr *ANY) copy() RR {
	return &ANY{rr.Hdr}
}

func (rr *APL) copy() RR {
	Prefixes := make([]APLPrefix, len(rr.Prefixes))
	for i, e := range rr.Prefixes {
		Prefixes[i] = e.copy()
	}
	return &APL{rr.Hdr, Prefixes}
}

func (rr *AVC) copy() RR {
	return &AVC{rr.Hdr, cloneSlice(rr.Txt)}
}

func (rr *CAA) copy() RR {
	return &CAA{
		rr.Hdr,
		rr.Flag,
		rr.Tag,
		rr.Value,
	}
}

func (rr *CDNSKEY) copy() RR {
	return &CDNSKEY{*rr.DNSKEY.copy().(*DNSKEY)}
}

func (rr *CDS) copy() RR {
	return &CDS{*rr.DS.copy().(*DS)}
}

func (rr *CERT) copy() RR {
	return &CERT{
		rr.Hdr,
		rr.Type,
		rr.KeyTag,
		rr.Algorithm,
		rr.Certificate,
	}
}

func (rr *CNAME) copy() RR {
	return &CNAME{rr.Hdr, rr.Target}
}

func (rr *CSYNC) copy() RR {
	return &CSYNC{
		rr.Hdr,
		rr.Serial,
		rr.Flags,
		cloneSlice(rr.TypeBitMap),
	}
}

func (rr *DHCID) copy() RR {
	return &DHCID{rr.Hdr, rr.Digest}
}

func (rr *DLV) copy() RR {
	return &DLV{*rr.DS.copy().(*DS)}
}

func (rr *DNAME) copy() RR {
	return &DNAME{rr.Hdr, rr.Target}
}

func (rr *DNSKEY) copy() RR {
	return &DNSKEY{
		rr.Hdr,
		rr.Flags,
		rr.Protocol,
		rr.Algorithm,
		rr.PublicKey,
	}
}

func (rr *DS) copy() RR {
	return &DS{
		rr.Hdr,
		rr.KeyTag,
		rr.Algorithm,
		rr.DigestType,
		rr.Digest,
	}
}

func (rr *EID) copy() RR {
	return &EID{rr.Hdr, rr.Endpoint}
}

func (rr *EUI48) copy() RR {
	return &EUI48{rr.Hdr, rr.Address}
}

func (rr *EUI64) copy() RR {
	return &EUI64{rr.Hdr, rr.Address}
}

func (rr *GID) copy() RR {
	return &GID{rr.Hdr, rr.Gid}
}

func (rr *GPOS) copy() RR {
	return &GPOS{
		rr.Hdr,
		rr.Longitude,
		rr.Latitude,
		rr.Altitude,
	}
}

func (rr *HINFO) copy() RR {
	return &HINFO{rr.Hdr, rr.Cpu, rr.Os}
}

func (rr *HIP) copy() RR {
	return &HIP{
		rr.Hdr,
		rr.HitLength,
		rr.PublicKeyAlgorithm,
		rr.PublicKeyLength,
		rr.Hit,
		rr.PublicKey,
		cloneSlice(rr.RendezvousServers),
	}
}

func (rr *HTTPS) copy() RR {
	return &HTTPS{*rr.SVCB.copy().(*SVCB)}
}

func (rr *IPSECKEY) copy() RR {
	return &IPSECKEY{
		rr.Hdr,
		rr.Precedence,
		rr.GatewayType,
		rr.Algorithm,
		cloneSlice(rr.GatewayAddr),
		rr.GatewayHost,
		rr.PublicKey,
	}
}

func (rr *KEY) copy() RR {
	return &KEY{*rr.DNSKEY.copy().(*DNSKEY)}
}

func (rr *KX) copy() RR {
	return &KX{rr.Hdr, rr.Preference, rr.Exchanger}
}

func (rr *L32) copy() RR {
	return &L32{rr.Hdr, rr.Preference, cloneSlice(rr.Locator32)}
}

func (rr *L64) copy() RR {
	return &L64{rr.Hdr, rr.Preference, rr.Locator64}
}

func (rr *LOC) copy() RR {
	return &LOC{
		rr.Hdr,
		rr.Version,
		rr.Size,
		rr.HorizPre,
		rr.VertPre,
		rr.Latitude,
		rr.Longitude,
		rr.Altitude,
	}
}

func (rr *LP) copy() RR {
	return &LP{rr.Hdr, rr.Preference, rr.Fqdn}
}

func (rr *MB) copy() RR {
	return &MB{rr.Hdr, rr.Mb}
}

func (rr *MD) copy() RR {
	return &MD{rr.Hdr, rr.Md}
}

func (rr *MF) copy() RR {
	return &MF{rr.Hdr, rr.Mf}
}

func (rr *MG) copy() RR {
	return &MG{rr.Hdr, rr.Mg}
}

func (rr *MINFO) copy() RR {
	return &MINFO{rr.Hdr, rr.Rmail, rr.Email}
}

func (rr *MR) copy() RR {
	return &MR{rr.Hdr, rr.Mr}
}

func (rr *MX) copy() RR {
	return &MX{rr.Hdr, rr.Preference, rr.Mx}
}

func (rr *NAPTR) copy() RR {
	return &NAPTR{
		rr.Hdr,
		rr.Order,
		rr.Preference,
		rr.Flags,
		rr.Service,
		rr.Regexp,
		rr.Replacement,
	}
}

func (rr *NID) copy() RR {
	return &NID{rr.Hdr, rr.Preference, rr.NodeID}
}

func (rr *NIMLOC) copy() RR {
	return &NIMLOC{rr.Hdr, rr.Locator}
}

func (rr *NINFO) copy() RR {
	return &NINFO{rr.Hdr, cloneSlice(rr.ZSData)}
}

func (rr *NS) copy() RR {
	return &NS{rr.Hdr, rr.Ns}
}

func (rr *NSAPPTR) copy() RR {
	return &NSAPPTR{rr.Hdr, rr.Ptr}
}

func (rr *NSEC) copy() RR {
	return &NSEC{rr.Hdr, rr.NextDomain, cloneSlice(rr.TypeBitMap)}
}

func (rr *NSEC3) copy() RR {
	return &NSEC3{
		rr.Hdr,
		rr.Hash,
		rr.Flags,
		rr.Iterations,
		rr.SaltLength,
		rr.Salt,
		rr.HashLength,
		rr.NextDomain,
		cloneSlice(rr.TypeBitMap),
	}
}

func (rr *NSEC3PARAM) copy() RR {
	return &NSEC3PARAM{
		rr.Hdr,
		rr.Hash,
		rr.Flags,
		rr.Iterations,
		rr.SaltLength,
		rr.Salt,
	}
}

func (rr *NULL) copy() RR {
	return &NULL{rr.Hdr, rr.Data}
}

func (rr *OPENPGPKEY) copy() RR {
	return &OPENPGPKEY{rr.Hdr, rr.PublicKey}
}

func (rr *OPT) copy() RR {
	Option := make([]EDNS0, len(rr.Option))
	for i, e := range rr.Option {
		Option[i] = e.copy()
	}
	return &OPT{rr.Hdr, Option}
}

func (rr *PTR) copy() RR {
	return &PTR{rr.Hdr, rr.Ptr}
}

func (rr *PX) copy() RR {
	return &PX{
		rr.Hdr,
		rr.Preference,
		rr.Map822,
		rr.Mapx400,
	}
}

func (rr *RFC3597) copy() RR {
	return &RFC3597{rr.Hdr, rr.Rdata}
}

func (rr *RKEY) copy() RR {
	return &RKEY{
		rr.Hdr,
		rr.Flags,
		rr.Protocol,
		rr.Algorithm,
		rr.PublicKey,
	}
}

func (rr *RP) copy() RR {
	return &RP{rr.Hdr, rr.Mbox, rr.Txt}
}

func (rr *RRSIG) copy() RR {
	return &RRSIG{
		rr.Hdr,
		rr.TypeCovered,
		rr.Algorithm,
		rr.Labels,
		rr.OrigTtl,
		rr.Expiration,
		rr.Inception,
		rr.KeyTag,
		rr.SignerName,
		rr.Signature,
	}
}

func (rr *RT) copy() RR {
	return &RT{rr.Hdr, rr.Preference, rr.Host}
}

func (rr *SIG) copy() RR {
	return &SIG{*rr.RRSIG.copy().(*RRSIG)}
}

func (rr *SMIMEA) copy() RR {
	return &SMIMEA{
		rr.Hdr,
		rr.Usage,
		rr.Selector,
		rr.MatchingType,
		rr.Certificate,
	}
}

func (rr *SOA) copy() RR {
	return &SOA{
		rr.Hdr,
		rr.Ns,
		rr.Mbox,
		rr.Serial,
		rr.Refresh,
		rr.Retry,
		rr.Expire,
		rr.Minttl,
	}
}

func (rr *SPF) copy() RR {
	return &SPF{rr.Hdr, cloneSlice(rr.Txt)}
}

func (rr *SRV) copy() RR {
	return &SRV{
		rr.Hdr,
		rr.Priority,
		rr.Weight,
		rr.Port,
		rr.Target,
	}
}

func (rr *SSHFP) copy() RR {
	return &SSHFP{
		rr.Hdr,
		rr.Algorithm,
		rr.Type,
		rr.FingerPrint,
	}
}

func (rr *SVCB) copy() RR {
	Value := make([]SVCBKeyValue, len(rr.Value))
	for i, e := range rr.Value {
		Value[i] = e.copy()
	}
	return &SVCB{
		rr.Hdr,
		rr.Priority,
		rr.Target,
		Value,
	}
}

func (rr *TA) copy() RR {
	return &TA{
		rr.Hdr,
		rr.KeyTag,
		rr.Algorithm,
		rr.DigestType,
		rr.Digest,
	}
}

func (rr *TALINK) copy() RR {
	return &TALINK{rr.Hdr, rr.PreviousName, rr.NextName}
}

func (rr *TKEY) copy() RR {
	return &TKEY{
		rr.Hdr,
		rr.Algorithm,
		rr.Inception,
		rr.Expiration,
		rr.Mode,
		rr.Error,
		rr.KeySize,
		rr.Key,
		rr.OtherLen,
		rr.OtherData,
	}
}

func (rr *TLSA) copy() RR {
	return &TLSA{
		rr.Hdr,
		rr.Usage,
		rr.Selector,
		rr.MatchingType,
		rr.Certificate,
	}
}

func (rr *TSIG) copy() RR {
	return &TSIG{
		rr.Hdr,
		rr.Algorithm,
		rr.TimeSigned,
		rr.Fudge,
		rr.MACSize,
		rr.MAC,
		rr.OrigId,
		rr.Error,
		rr.OtherLen,
		rr.OtherData,
	}
}

func (rr *TXT) copy() RR {
	return &TXT{rr.Hdr, cloneSlice(rr.Txt)}
}

func (rr *UID) copy() RR {
	return &UID{rr.Hdr, rr.Uid}
}

func (rr *UINFO) copy() RR {
	return &UINFO{rr.Hdr, rr.Uinfo}
}

func (rr *URI) copy() RR {
	return &URI{
		rr.Hdr,
		rr.Priority,
		rr.Weight,
		rr.Target,
	}
}

func (rr *X25) copy() RR {
	return &X25{rr.Hdr, rr.PSDNAddress}
}

func (rr *ZONEMD) copy() RR {
	return &ZONEMD{
		rr.Hdr,
		rr.Serial,
		rr.Scheme,
		rr.Hash,
		rr.Digest,
	}
}
*/
