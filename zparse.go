// Code generated by "go run parse_generate.go"; DO NOT EDIT.

package dns

func parse(rr RR, c *zlexer, o string) *ParseError {
	switch x := rr.(type) {
	case *ANY:
		return x.parse(c, o)
	case *NULL:
		return x.parse(c, o)
	case *CNAME:
		return x.parse(c, o)
	case *HINFO:
		return x.parse(c, o)
	case *MB:
		return x.parse(c, o)
	case *MG:
		return x.parse(c, o)
	case *MINFO:
		return x.parse(c, o)
	case *MR:
		return x.parse(c, o)
	case *MF:
		return x.parse(c, o)
	case *MD:
		return x.parse(c, o)
	case *MX:
		return x.parse(c, o)
	case *AFSDB:
		return x.parse(c, o)
	case *X25:
		return x.parse(c, o)
	case *RT:
		return x.parse(c, o)
	case *NS:
		return x.parse(c, o)
	case *PTR:
		return x.parse(c, o)
	case *RP:
		return x.parse(c, o)
	case *SOA:
		return x.parse(c, o)
	case *TXT:
		return x.parse(c, o)
	case *SPF:
		return x.parse(c, o)
	case *AVC:
		return x.parse(c, o)
	case *SRV:
		return x.parse(c, o)
	case *NAPTR:
		return x.parse(c, o)
	case *CERT:
		return x.parse(c, o)
	case *DNAME:
		return x.parse(c, o)
	case *A:
		return x.parse(c, o)
	case *AAAA:
		return x.parse(c, o)
	case *PX:
		return x.parse(c, o)
	case *GPOS:
		return x.parse(c, o)
	case *LOC:
		return x.parse(c, o)
	case *SIG:
		return x.parse(c, o)
	case *RRSIG:
		return x.parse(c, o)
	case *NSEC:
		return x.parse(c, o)
	case *DLV:
		return x.parse(c, o)
	case *CDS:
		return x.parse(c, o)
	case *DS:
		return x.parse(c, o)
	case *KX:
		return x.parse(c, o)
	case *TA:
		return x.parse(c, o)
	case *TALINK:
		return x.parse(c, o)
	case *SSHFP:
		return x.parse(c, o)
	case *KEY:
		return x.parse(c, o)
	case *CDNSKEY:
		return x.parse(c, o)
	case *DNSKEY:
		return x.parse(c, o)
	case *IPSECKEY:
		return x.parse(c, o)
	case *AMTRELAY:
		return x.parse(c, o)
	case *RKEY:
		return x.parse(c, o)
	case *NSAPPTR:
		return x.parse(c, o)
	case *NSEC3:
		return x.parse(c, o)
	case *NSEC3PARAM:
		return x.parse(c, o)
	case *TKEY:
		return x.parse(c, o)
	case *URI:
		return x.parse(c, o)
	case *DHCID:
		return x.parse(c, o)
	case *TLSA:
		return x.parse(c, o)
	case *SMIMEA:
		return x.parse(c, o)
	case *HIP:
		return x.parse(c, o)
	case *NINFO:
		return x.parse(c, o)
	case *NID:
		return x.parse(c, o)
	case *L32:
		return x.parse(c, o)
	case *L64:
		return x.parse(c, o)
	case *LP:
		return x.parse(c, o)
	case *EUI48:
		return x.parse(c, o)
	case *EUI64:
		return x.parse(c, o)
	case *CAA:
		return x.parse(c, o)
	case *UID:
		return x.parse(c, o)
	case *GID:
		return x.parse(c, o)
	case *UINFO:
		return x.parse(c, o)
	case *EID:
		return x.parse(c, o)
	case *NIMLOC:
		return x.parse(c, o)
	case *OPENPGPKEY:
		return x.parse(c, o)
	case *CSYNC:
		return x.parse(c, o)
	case *ZONEMD:
		return x.parse(c, o)
	case *APL:
		return x.parse(c, o)
	}
	// If here we need to setup the channel and send the elements.
	// if here, we don't have the RR in our pkg, check if it does Packer.
	//	if x, ok := rr.(Packer); ok {
	//		return x.Pack(msg, off)
	//	}
	return &ParseError{err: "no parse defined"}
}
