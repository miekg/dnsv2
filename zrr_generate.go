//go:build ignore

// rr_generate generates zrr.go which houses all the methods that implement the RR interface. This handles
// the struct tags on rr.octets as well.

package main

import (
	"bytes"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"html/template"
	"log"
	"os"
	"reflect"
)

var hdr = `
// Code generated by "go run rr_generate.go"; DO NOT EDIT.

package dns

import (
	"github.com/miekg/dnsv2/dnswire"
)

`

var rrFunc = template.Must(template.New("rrFunc").Parse(`{{range .}}
func (rr *{{.}}) Name(x ...dnswire.Name) (dnswire.Name, error)    { return _Name(rr, x...) }
func (rr *{{.}}) Type(x ...dnswire.Type) (dnswire.Type, error)    { return _Type(rr, x...) }
func (rr *{{.}}) DataLen(x ...uint16) (uint16, error)             { return _DataLen(rr, x...) }
func (rr *{{.}}) Class(x ...dnswire.Class) (dnswire.Class, error) { return _Class(rr, x...) }
func (rr *{{.}}) TTL(x ...dnswire.TTL) (dnswire.TTL, error)       { return _TTL(rr, x...) }
func (rr *{{.}}) String() string                                  { return _String(rr) }
func (rr *{{.}}) Len() int                                        { return _Len(rr) }
func (rr *{{.}}) Octets(x ...[]byte) []byte {
	if len(x) == 0 {
		return rr.octets
	}
	rr.octets = x[0]
	return nil
}
{{end}}`))

const out = "_zrr.go" // does not work for checking the struct tags yet.

func main() {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, "rr.go", nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("Failed to generate %s: %v", out, err)
	}

	types := []string{}
	for _, decl := range node.Decls {
		declType := reflect.TypeOf(decl)

		if declType.String() == "*ast.GenDecl" {
			genDecl := decl.(*ast.GenDecl)
			if genDecl.Tok == token.TYPE {
				for _, spec := range genDecl.Specs {
					if typeSpec, ok := spec.(*ast.TypeSpec); ok {
						types = append(types, typeSpec.Name.Name)
					}
				}
			}
		}
	}
	source := &bytes.Buffer{}
	source.WriteString(hdr)
	if err := rrFunc.Execute(source, types); err != nil {
		log.Fatalf("Failed to generate %s: %v", out, err)
	}

	formatted, err := format.Source(source.Bytes())
	if err != nil {
		source.WriteTo(os.Stderr)
		log.Fatalf("Failed to generate %s: %v", out, err)
	}

	if err := os.WriteFile(out, formatted, 0640); err != nil {
		log.Fatalf("Failed to generate %s: %v", out, err)
	}
}
