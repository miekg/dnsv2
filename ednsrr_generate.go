//go:build ignore

// rr_generate generates zrr.go which houses all the methods that implement the RR interface.

package main

import (
	"bytes"
	"flag"
	"html/template"
	"log"
	"strings"

	"github.com/miekg/dnsv2/internal/generate"
)

var hdr = `
// Code generated by "go run ednsrr_generate.go"; DO NOT EDIT.

package dns

`

var CodeToRR = template.Must(template.New("TypeToRR").Parse(`
// CodeToRR is a map of constructors for each EDNS0 RR type.
var CodeToRR = map[uint16]func() EDNS0{
{{range .}}  Code{{.}}:  func() EDNS0 { return new({{.}}) },
{{end}}                    }

`))

var RRToCode = template.Must(template.New("RRToCode").Parse(`
// RRToCode is the reverse of CodeToRR, implemented as a function.
func RRToCode(rr EDNS0) uint16 {
    switch rr.(type) {
{{range .}}  case *{{.}}:
	return Code{{.}}
{{end}} }
    return CodeNone
}

`))

var CodeToString = template.Must(template.New("codeToString").Parse(`
// CodeToString is a map of strings for each EDNS0 RR type.
var CodeToString = map[uint16]string{
{{range .}}  Code{{.}}: "{{.}}",
{{end}}
}

`))

var interfaceFunc = template.Must(template.New("interfaceFunc").Parse(`
{{range .}}  func (rr *{{.}}) Header() *Header { return &rr.Hdr }
func (rr *{{.}}) Pseudo() bool { return true }
{{end}}

`))

var funcMap = template.FuncMap{
	"join": strings.Join,
}

var fieldFunc = template.Must(template.New("fieldFunc").Funcs(funcMap).Parse(`
{{range $t, $fs := .}}  func (rr *{{$t}}) Data() []Field { return []Field{ {{join $fs ","}} }}
{{end}}

`))

const out = "zednsrr.go"

func main() {
	flag.Parse()
	types, err := generate.Types("edns_types.go")
	if err != nil {
		log.Fatalf("Failed to generate %s: %v", out, err)
	}

	source := &bytes.Buffer{}
	source.WriteString(hdr)
	if err := interfaceFunc.Execute(source, types); err != nil {
		log.Fatalf("Failed to generate %s: %v", out, err)
	}
	if err := CodeToRR.Execute(source, types); err != nil {
		log.Fatalf("Failed to generate %s: %v", out, err)
	}
	if err := RRToCode.Execute(source, types); err != nil {
		log.Fatalf("Failed to generate %s: %v", out, err)
	}
	if err := CodeToString.Execute(source, types); err != nil {
		log.Fatalf("Failed to generate %s: %v", out, err)
	}

	fields, err := generate.Fields("edns_types.go")
	if err != nil {
		log.Fatalf("Failed to generate %s: %v", out, err)
	}
	if err := fieldFunc.Execute(source, fields); err != nil {
		log.Fatalf("Failed to generate %s: %v", out, err)
	}

	generate.Write(source, out)
}
