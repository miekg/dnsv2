//go:build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"log"
	"os"
	"strings"

	"github.com/miekg/dnsv2/internal/generate"
)

var hdr = `
// Code generated by "go run msg_generate.go"; DO NOT EDIT.

package dns

import "golang.org/x/crypto/cryptobyte"

`

const out = "_zmsg.go"

var flagDebug = flag.Bool("debug", false, "Emit the non-formatted code to standard output and do not write it to a file.")

func main() {
	flag.Parse()
	specs, err := generate.StructTypeSpecs("types.go")
	if err != nil {
		log.Fatalf("Failed to generate %s: %v", out, err)
	}
	b := &bytes.Buffer{}
	b.WriteString(hdr)

	for _, spec := range specs {
		rrname := spec.Name.Name
		if rrname == "APLPrefix" {
			continue
		}

		//
		// Pack functions
		//

		fmt.Fprintf(b, "func (rr *%s) pack(msg []byte, off int, compression map[string]uint16, compress bool) (off1 int, err error) {\n", rrname)

		strct := spec.Type.(*ast.StructType)
		for _, field := range strct.Fields.List {
			if len(field.Names) == 0 {
				continue
			}
			fieldname := field.Names[0].String()
			if fieldname == "Hdr" {
				continue
			}

			o := func(s string) {
				fmt.Fprintf(b, s, fieldname)
				fmt.Fprint(b, `if err != nil {
		return off, err
		}
		`)
			}
			// fieldtype is either slice or the actual singular type name.
			fieldtype := ""
			if id, ok := field.Type.(*ast.Ident); ok {
				fieldtype = id.Name
			}
			if _, ok := field.Type.(*ast.ArrayType); ok {
				fieldtype = "slice"
			}

			tag := ""
			if field.Tag != nil {
				tag = strings.Trim(field.Tag.Value, "`")
			}

			if fieldtype == "slice" {
				switch tag {
				case `dns:"-"`: // ignored
				case `dns:"txt"`:
					o("off, err = packStringTxt(rr.%s, msg, off)\n")
				case `dns:"opt"`:
					o("off, err = packOpt(rr.%s, msg, off)\n")
				case `dns:"nsec"`:
					o("off, err = packNsec(rr.%s, msg, off)\n")
				case `dns:"pairs"`:
					o("off, err = packSVCB(rr.%s, msg, off)\n")
				case `dns:"domain-name"`:
					o("off, err = packDomainNames(rr.%s, msg, off, compression, false)\n")
				case `dns:"apl"`:
					o("off, err = packApl(rr.%s, msg, off)\n")
				default:
					log.Fatalln(rrname, fieldname, tag)
				}
				continue
			}

			// non-slice fields

			switch {
			case tag == `dns:"-"`: // ignored
			case tag == `dns:"cdomain-name"`:
				o("off, err = packDomainName(rr.%s, msg, off, compression, compress)\n")
			case tag == `dns:"domain-name"`:
				o("off, err = packDomainName(rr.%s, msg, off, compression, false)\n")
			case tag == `dns:"a"`:
				o("off, err = packA(rr.%s, msg, off)\n")
			case tag == `dns:"aaaa"`:
				o("off, err = packAAAA(rr.%s, msg, off)\n")
			case tag == `dns:"uint48"`:
				o("off, err = packUint48(rr.%s, msg, off)\n")
			case tag == `dns:"txt"`:
				o("off, err = packString(rr.%s, msg, off)\n")

			case strings.HasPrefix(tag, `dns:"size-base32`): // size-base32 can be packed just like base32
				fallthrough
			case tag == `dns:"base32"`:
				o("off, err = packStringBase32(rr.%s, msg, off)\n")

			case strings.HasPrefix(tag, `dns:"size-base64`): // size-base64 can be packed just like base64
				fallthrough
			case tag == `dns:"base64"`:
				o("off, err = packStringBase64(rr.%s, msg, off)\n")

			case strings.HasPrefix(tag, `dns:"size-hex:SaltLength`):
				// directly write instead of using o() so we get the error check in the correct place
				fmt.Fprintf(b, `// Only pack salt if value is not "-", i.e. empty
if rr.%s != "-" {
  off, err = packStringHex(rr.%s, msg, off)
  if err != nil {
    return off, err
  }
}
`, fieldname, fieldname)
				continue
			case strings.HasPrefix(tag, `dns:"size-hex`): // size-hex can be packed just like hex
				fallthrough
			case tag == `dns:"hex"`:
				o("off, err = packStringHex(rr.%s, msg, off)\n")
			case tag == `dns:"any"`:
				o("off, err = packStringAny(rr.%s, msg, off)\n")
			case tag == `dns:"octet"`:
				o("off, err = packStringOctet(rr.%s, msg, off)\n")
			case tag == `dns:"ipsechost"` || tag == `dns:"amtrelayhost"`:
				o("off, err = packIPSECGateway(rr.GatewayAddr, rr.%s, msg, off, rr.GatewayType, compression, false)\n")
			case tag == "":
				switch fieldtype {
				case "uint8":
					o("off, err = packUint8(rr.%s, msg, off)\n")
				case "uint16":
					o("off, err = packUint16(rr.%s, msg, off)\n")
				case "uint32":
					o("off, err = packUint32(rr.%s, msg, off)\n")
				case "uint64":
					o("off, err = packUint64(rr.%s, msg, off)\n")
				case "string":
					o("off, err = packString(rr.%s, msg, off)\n")
				default:
					log.Fatalln("No tag or basic type", rrname, fieldname, tag)
				}
			default:
				log.Fatalln(rrname, fieldname, tag)
			}
		}
		fmt.Fprint(b, "return off, nil }\n\n")

		//
		// Unpack functions
		//

		fmt.Fprintf(b, "func (rr *%s) unpack(data, msgBuf []byte) (err error) {\n", rrname)
		fmt.Fprintln(b, "s := cryptobyte.String(data)")

		for _, field := range strct.Fields.List {
			if len(field.Names) == 0 {
				continue
			}

			fieldname := field.Names[0].String()
			if fieldname == "Hdr" {
				continue
			}

			// fieldtype is either slice or the actual singular type name.
			fieldtype := ""
			if id, ok := field.Type.(*ast.Ident); ok {
				fieldtype = id.Name
			}
			if _, ok := field.Type.(*ast.ArrayType); ok {
				fieldtype = "slice"
			}

			tag := ""
			if field.Tag != nil {
				tag = strings.Trim(field.Tag.Value, "`")
			}

			errCheck := func() {
				fmt.Fprintln(b, "if err != nil { return err }")
			}
			unpackField := func(unpacker string) {
				fmt.Fprintf(b, "rr.%s, err = %s(&s)\n", fieldname, unpacker)
				errCheck()
			}
			unpackFieldBuf := func(unpacker string) {
				fmt.Fprintf(b, "rr.%s, err = %s(&s, msgBuf)\n", fieldname, unpacker)
				errCheck()
			}
			unpackFieldRest := func(unpacker string) {
				fmt.Fprintf(b, "rr.%s, err = %s(&s, len(s))\n", fieldname, unpacker)
				errCheck()
			}
			unpackFieldLength := func(unpacker, len string) {
				fmt.Fprintf(b, "rr.%s, err = %s(&s, int(rr.%s))\n", fieldname, unpacker, len)
				errCheck()
			}
			readInt := func(type_ string) {
				fmt.Fprintf(b, "if !s.Read%s(&rr.%s) { return errUnpackOverflow }\n", type_, fieldname)
			}

			// size-* are special, because they reference a struct member we should use for the length.
			if strings.HasPrefix(tag, `dns:"size-`) {
				structMember := structMember(tag)
				structTag := structTag(tag)
				switch structTag {
				case "hex":
					unpackFieldLength("unpackStringHex", structMember)
				case "base32":
					unpackFieldLength("unpackStringBase32", structMember)
				case "base64":
					unpackFieldLength("unpackStringBase64", structMember)
				default:
					log.Fatalln(rrname, fieldname, tag)
				}
				continue
			}

			if fieldtype == "slice" {
				switch tag {
				case `dns:"-"`: // ignored
				case `dns:"txt"`:
					unpackField("unpackStringTxt")
				case `dns:"opt"`:
					unpackField("unpackDataOpt")
				case `dns:"nsec"`:
					unpackField("unpackDataNsec")
				case `dns:"pairs"`:
					unpackField("unpackDataSVCB")
				case `dns:"domain-name"`:
					unpackFieldBuf("unpackDataDomainNames")
				case `dns:"apl"`:
					unpackField("unpackDataApl")
				default:
					log.Fatalln(rrname, fieldname, tag)
				}
				continue
			}

			switch tag {
			case `dns:"-"`: // ignored
			case `dns:"cdomain-name"`, `dns:"domain-name"`:
				unpackFieldBuf("unpackDomainName")
			case `dns:"a"`:
				unpackField("unpackDataA")
			case `dns:"aaaa"`:
				unpackField("unpackDataAAAA")
			case `dns:"uint48"`:
				readInt("Uint48")
			case `dns:"txt"`:
				unpackField("unpackString")
			case `dns:"base32"`:
				unpackFieldRest("unpackStringBase32")
			case `dns:"base64"`:
				unpackFieldRest("unpackStringBase64")
			case `dns:"hex"`:
				unpackFieldRest("unpackStringHex")
			case `dns:"any"`:
				unpackFieldRest("unpackStringAny")
			case `dns:"octet"`:
				unpackField("unpackStringOctet")
			case `dns:"ipsechost"`, `dns:"amtrelayhost"`:
				// TODO(tmthrgd): This is a particular unpleasant
				// way of dealing with this. Can we do better?
				// Probably not with the structs as they are.
				fmt.Fprintln(b, "rr.GatewayAddr, rr.GatewayHost, err = unpackIPSECGateway(&s, msgBuf, rr.GatewayType)")
				errCheck()
			case "":
				switch fieldtype {
				case "uint8":
					readInt("Uint8")
				case "uint16":
					readInt("Uint16")
				case "uint32":
					readInt("Uint32")
				case "uint64":
					readInt("Uint64")
				case "string":
					unpackField("unpackString")
				default:
					log.Fatalln("No tag or basic type", rrname, fieldname, tag)
				}
			default:
				log.Fatalln(rrname, fieldname, tag)
			}
		}
		fmt.Fprintln(b, "if !s.Empty() { return ErrTrailingRData }")
		fmt.Fprint(b, "return nil }\n\n")
	}

	println(b.String())
	formatted, err := format.Source(b.Bytes())
	if err != nil {
		b.WriteTo(os.Stderr)
		log.Fatalf("Failed to generate %s: %v", out, err)
	}

	if *flagDebug {
		fmt.Print(string(formatted))
		return
	}

	if err := os.WriteFile(out, formatted, 0640); err != nil {
		log.Fatalf("Failed to generate %s: %v", out, err)
	}
}

// structMember will take a tag like dns:"size-base32:SaltLength" and return the last part of this string.
func structMember(s string) string {
	idx := strings.LastIndex(s, ":")
	return strings.TrimSuffix(s[idx+1:], `"`)
}

// structTag will take a tag like dns:"size-base32:SaltLength" and return base32.
func structTag(s string) string {
	s = strings.TrimPrefix(s, `dns:"size-`)
	s, _, _ = strings.Cut(s, ":")
	return s
}
