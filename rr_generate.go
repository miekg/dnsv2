//go:build ignore

// rr_generate generates zrr.go which houses all the methods that implement the RR interface.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"html/template"
	"log"
	"os"
	"reflect"
	"unicode"
	"unicode/utf8"
)

var hdr = `
// Code generated by "go run rr_generate.go"; DO NOT EDIT.

package dns

`

var TypeToRR = template.Must(template.New("TypeToRR").Parse(`
// TypeToRR is a map of constructors for each RR type.
var TypeToRR = map[uint16]func() RR{
{{range .}}{{if ne . "RFC3597"}}  Type{{.}}:  func() RR { return new({{.}}) },
{{end}}{{end}}                    }

`))

var RRToType = template.Must(template.New("RRToType").Parse(`
// RRToType is the reverse of TypeToRR, implemented as a function.
func RRToType(rr RR) dnswire.Type {
    switch rr.(type) {
{{range .}}{{if ne . "RFC3597"}}  case *{{.}}:
	return Type{{.}}
{{end}}{{end}} }
    return TypeNone
}

`))

const out = "_zrr.go" // does not work for checking the struct tags yet. TMP TODO

var flagDebug = flag.Bool("debug", false, "Emit the non-formatted code to standard output and do not write it to a file.")

func main() {
	flag.Parse()
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, "types.go", nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("Failed to generate %s: %v", out, err)
	}

	// Grab all exported types from types.go
	types := []string{}
	for _, decl := range node.Decls {
		declType := reflect.TypeOf(decl)

		if declType.String() == "*ast.GenDecl" {
			genDecl := decl.(*ast.GenDecl)
			if genDecl.Tok == token.TYPE {
				for _, spec := range genDecl.Specs {
					if typeSpec, ok := spec.(*ast.TypeSpec); ok {
						rn, _ := utf8.DecodeRuneInString(typeSpec.Name.Name)
						if unicode.IsUpper(rn) {
							types = append(types, typeSpec.Name.Name)
						}
					}
				}
			}
		}
	}
	source := &bytes.Buffer{}
	source.WriteString(hdr)
	if err := TypeToRR.Execute(source, types); err != nil {
		log.Fatalf("Failed to generate %s: %v", out, err)
	}
	if err := RRToType.Execute(source, types); err != nil {
		log.Fatalf("Failed to generate %s: %v", out, err)
	}

	if *flagDebug {
		fmt.Print(source.String())
		return
	}

	formatted, err := format.Source(source.Bytes())
	if err != nil {
		source.WriteTo(os.Stderr)
		log.Fatalf("Failed to generate %s: %v", out, err)
	}

	if err := os.WriteFile(out, formatted, 0640); err != nil {
		log.Fatalf("Failed to generate %s: %v", out, err)
	}
}
