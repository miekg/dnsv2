// Code generated by "go run len_generate.go"; DO NOT EDIT.

package dns

import (
	"encoding/base64"
	"net"
)

func (rr *ANY) Len() int {
	l := rr.Hdr.Len()
	return l
}

func (rr *NULL) Len() int {
	l := rr.Hdr.Len()
	l += len(rr.Null)
	return l
}

func (rr *CNAME) Len() int {
	l := rr.Hdr.Len()
	l += domainNameLen(rr.Target, off+l, compression, true)
	return l
}

func (rr *HINFO) Len() int {
	l := rr.Hdr.Len()
	l += len(rr.Cpu) + 1
	l += len(rr.Os) + 1
	return l
}

func (rr *MB) Len() int {
	l := rr.Hdr.Len()
	l += domainNameLen(rr.Mb, off+l, compression, true)
	return l
}

func (rr *MG) Len() int {
	l := rr.Hdr.Len()
	l += domainNameLen(rr.Mg, off+l, compression, true)
	return l
}

func (rr *MINFO) Len() int {
	l := rr.Hdr.Len()
	l += domainNameLen(rr.Rmail, off+l, compression, true)
	l += domainNameLen(rr.Email, off+l, compression, true)
	return l
}

func (rr *MR) Len() int {
	l := rr.Hdr.Len()
	l += domainNameLen(rr.Mr, off+l, compression, true)
	return l
}

func (rr *MF) Len() int {
	l := rr.Hdr.Len()
	l += domainNameLen(rr.Mf, off+l, compression, true)
	return l
}

func (rr *MD) Len() int {
	l := rr.Hdr.Len()
	l += domainNameLen(rr.Md, off+l, compression, true)
	return l
}

func (rr *MX) Len() int {
	l := rr.Hdr.Len()
	l += 2 // Preference
	l += domainNameLen(rr.Mx, off+l, compression, true)
	return l
}

func (rr *AFSDB) Len() int {
	l := rr.Hdr.Len()
	l += 2 // Subtype
	l += domainNameLen(rr.Hostname, off+l, compression, false)
	return l
}

func (rr *X25) Len() int {
	l := rr.Hdr.Len()
	l += len(rr.PSDNAddress) + 1
	return l
}

func (rr *RT) Len() int {
	l := rr.Hdr.Len()
	l += 2 // Preference
	l += domainNameLen(rr.Host, off+l, compression, false)
	return l
}

func (rr *NS) Len() int {
	l := rr.Hdr.Len()
	l += domainNameLen(rr.Ns, off+l, compression, true)
	return l
}

func (rr *PTR) Len() int {
	l := rr.Hdr.Len()
	l += domainNameLen(rr.Ptr, off+l, compression, true)
	return l
}

func (rr *RP) Len() int {
	l := rr.Hdr.Len()
	l += domainNameLen(rr.Mbox, off+l, compression, false)
	l += domainNameLen(rr.Txt, off+l, compression, false)
	return l
}

func (rr *SOA) Len() int {
	l := rr.Hdr.Len()
	l += domainNameLen(rr.Ns, off+l, compression, true)
	l += domainNameLen(rr.Mbox, off+l, compression, true)
	l += 4 // Serial
	l += 4 // Refresh
	l += 4 // Retry
	l += 4 // Expire
	l += 4 // Minttl
	return l
}

func (rr *TXT) Len() int {
	l := rr.Hdr.Len()
	for _, x := range rr.Txt {
		l += len(x) + 1
	}
	return l
}

func (rr *SPF) Len() int {
	l := rr.Hdr.Len()
	for _, x := range rr.Txt {
		l += len(x) + 1
	}
	return l
}

func (rr *AVC) Len() int {
	l := rr.Hdr.Len()
	for _, x := range rr.Txt {
		l += len(x) + 1
	}
	return l
}

func (rr *SRV) Len() int {
	l := rr.Hdr.Len()
	l += 2 // Priority
	l += 2 // Weight
	l += 2 // Port
	l += domainNameLen(rr.Target, off+l, compression, false)
	return l
}

func (rr *NAPTR) Len() int {
	l := rr.Hdr.Len()
	l += 2 // Order
	l += 2 // Preference
	l += len(rr.Flags) + 1
	l += len(rr.Service) + 1
	l += len(rr.Regexp) + 1
	l += domainNameLen(rr.Replacement, off+l, compression, false)
	return l
}

func (rr *CERT) Len() int {
	l := rr.Hdr.Len()
	l += 2 // Type
	l += 2 // KeyTag
	l++    // Algorithm
	l += base64.StdEncoding.DecodedLen(len(rr.Certificate))
	return l
}

func (rr *DNAME) Len() int {
	l := rr.Hdr.Len()
	l += domainNameLen(rr.Target, off+l, compression, false)
	return l
}

func (rr *A) Len() int {
	l := rr.Hdr.Len()
	if len(rr.A) != 0 {
		l += net.IPv4len
	}
	return l
}

func (rr *AAAA) Len() int {
	l := rr.Hdr.Len()
	if len(rr.AAAA) != 0 {
		l += net.IPv6len
	}
	return l
}

func (rr *PX) Len() int {
	l := rr.Hdr.Len()
	l += 2 // Preference
	l += domainNameLen(rr.Map822, off+l, compression, false)
	l += domainNameLen(rr.Mapx400, off+l, compression, false)
	return l
}

func (rr *GPOS) Len() int {
	l := rr.Hdr.Len()
	l += len(rr.Longitude) + 1
	l += len(rr.Latitude) + 1
	l += len(rr.Altitude) + 1
	return l
}

func (rr *LOC) Len() int {
	l := rr.Hdr.Len()
	l++    // Version
	l++    // Size
	l++    // HorizPre
	l++    // VertPre
	l += 4 // Latitude
	l += 4 // Longitude
	l += 4 // Altitude
	return l
}

func (rr *SIG) Len() int {
	l := rr.Hdr.Len()
	return l
}

func (rr *RRSIG) Len() int {
	l := rr.Hdr.Len()
	l += 2 // TypeCovered
	l++    // Algorithm
	l++    // Labels
	l += 4 // OrigTtl
	l += 4 // Expiration
	l += 4 // Inception
	l += 2 // KeyTag
	l += domainNameLen(rr.SignerName, off+l, compression, false)
	l += base64.StdEncoding.DecodedLen(len(rr.Signature))
	return l
}

func (rr *DLV) Len() int {
	l := rr.Hdr.Len()
	return l
}

func (rr *CDS) Len() int {
	l := rr.Hdr.Len()
	return l
}

func (rr *DS) Len() int {
	l := rr.Hdr.Len()
	l += 2 // KeyTag
	l++    // Algorithm
	l++    // DigestType
	l += len(rr.Digest) / 2
	return l
}

func (rr *KX) Len() int {
	l := rr.Hdr.Len()
	l += 2 // Preference
	l += domainNameLen(rr.Exchanger, off+l, compression, false)
	return l
}

func (rr *TA) Len() int {
	l := rr.Hdr.Len()
	l += 2 // KeyTag
	l++    // Algorithm
	l++    // DigestType
	l += len(rr.Digest) / 2
	return l
}

func (rr *TALINK) Len() int {
	l := rr.Hdr.Len()
	l += domainNameLen(rr.PreviousName, off+l, compression, false)
	l += domainNameLen(rr.NextName, off+l, compression, false)
	return l
}

func (rr *SSHFP) Len() int {
	l := rr.Hdr.Len()
	l++ // Algorithm
	l++ // Type
	l += len(rr.FingerPrint) / 2
	return l
}

func (rr *KEY) Len() int {
	l := rr.Hdr.Len()
	return l
}

func (rr *CDNSKEY) Len() int {
	l := rr.Hdr.Len()
	return l
}

func (rr *DNSKEY) Len() int {
	l := rr.Hdr.Len()
	l += 2 // Flags
	l++    // Protocol
	l++    // Algorithm
	l += base64.StdEncoding.DecodedLen(len(rr.PublicKey))
	return l
}

func (rr *IPSECKEY) Len() int {
	l := rr.Hdr.Len()
	l++ // Precedence
	l++ // GatewayType
	l++ // Algorithm
	switch rr.GatewayType {
	case IPSECGatewayIPv4:
		l += net.IPv4len
	case IPSECGatewayIPv6:
		l += net.IPv6len
	case IPSECGatewayHost:
		l += len(rr.GatewayHost) + 1
	}
	l += base64.StdEncoding.DecodedLen(len(rr.PublicKey))
	return l
}

func (rr *AMTRELAY) Len() int {
	l := rr.Hdr.Len()
	l++ // Precedence
	l++ // GatewayType
	switch rr.GatewayType {
	case AMTRELAYIPv4:
		l += net.IPv4len
	case AMTRELAYIPv6:
		l += net.IPv6len
	case AMTRELAYHost:
		l += len(rr.GatewayHost) + 1
	}
	return l
}

func (rr *RKEY) Len() int {
	l := rr.Hdr.Len()
	l += 2 // Flags
	l++    // Protocol
	l++    // Algorithm
	l += base64.StdEncoding.DecodedLen(len(rr.PublicKey))
	return l
}

func (rr *NSAPPTR) Len() int {
	l := rr.Hdr.Len()
	l += domainNameLen(rr.Ptr, off+l, compression, false)
	return l
}

func (rr *NSEC3PARAM) Len() int {
	l := rr.Hdr.Len()
	l++    // Hash
	l++    // Flags
	l += 2 // Iterations
	l++    // SaltLength
	l += len(rr.Salt) / 2
	return l
}

func (rr *TKEY) Len() int {
	l := rr.Hdr.Len()
	l += domainNameLen(rr.Algorithm, off+l, compression, false)
	l += 4 // Inception
	l += 4 // Expiration
	l += 2 // Mode
	l += 2 // Error
	l += 2 // KeySize
	l += len(rr.Key) / 2
	l += 2 // OtherLen
	l += len(rr.OtherData) / 2
	return l
}

func (rr *RFC3597) Len() int {
	l := rr.Hdr.Len()
	l += len(rr.Rdata) / 2
	return l
}

func (rr *URI) Len() int {
	l := rr.Hdr.Len()
	l += 2 // Priority
	l += 2 // Weight
	l += len(rr.Target)
	return l
}

func (rr *DHCID) Len() int {
	l := rr.Hdr.Len()
	l += base64.StdEncoding.DecodedLen(len(rr.Digest))
	return l
}

func (rr *TLSA) Len() int {
	l := rr.Hdr.Len()
	l++ // Usage
	l++ // Selector
	l++ // MatchingType
	l += len(rr.Certificate) / 2
	return l
}

func (rr *SMIMEA) Len() int {
	l := rr.Hdr.Len()
	l++ // Usage
	l++ // Selector
	l++ // MatchingType
	l += len(rr.Certificate) / 2
	return l
}

func (rr *HIP) Len() int {
	l := rr.Hdr.Len()
	l++    // HitLength
	l++    // PublicKeyAlgorithm
	l += 2 // PublicKeyLength
	l += len(rr.Hit) / 2
	l += base64.StdEncoding.DecodedLen(len(rr.PublicKey))
	for _, x := range rr.RendezvousServers {
		l += domainNameLen(x, off+l, compression, false)
	}
	return l
}

func (rr *NINFO) Len() int {
	l := rr.Hdr.Len()
	for _, x := range rr.ZSData {
		l += len(x) + 1
	}
	return l
}

func (rr *NID) Len() int {
	l := rr.Hdr.Len()
	l += 2 // Preference
	l += 8 // NodeID
	return l
}

func (rr *L32) Len() int {
	l := rr.Hdr.Len()
	l += 2 // Preference
	if len(rr.Locator32) != 0 {
		l += net.IPv4len
	}
	return l
}

func (rr *L64) Len() int {
	l := rr.Hdr.Len()
	l += 2 // Preference
	l += 8 // Locator64
	return l
}

func (rr *LP) Len() int {
	l := rr.Hdr.Len()
	l += 2 // Preference
	l += domainNameLen(rr.Fqdn, off+l, compression, false)
	return l
}

func (rr *EUI48) Len() int {
	l := rr.Hdr.Len()
	l += 6 // Address
	return l
}

func (rr *EUI64) Len() int {
	l := rr.Hdr.Len()
	l += 8 // Address
	return l
}

func (rr *CAA) Len() int {
	l := rr.Hdr.Len()
	l++ // Flag
	l += len(rr.Tag) + 1
	l += len(rr.Value)
	return l
}

func (rr *UID) Len() int {
	l := rr.Hdr.Len()
	l += 4 // Uid
	return l
}

func (rr *GID) Len() int {
	l := rr.Hdr.Len()
	l += 4 // Gid
	return l
}

func (rr *UINFO) Len() int {
	l := rr.Hdr.Len()
	l += len(rr.Uinfo) + 1
	return l
}

func (rr *EID) Len() int {
	l := rr.Hdr.Len()
	l += len(rr.Endpoint) / 2
	return l
}

func (rr *NIMLOC) Len() int {
	l := rr.Hdr.Len()
	l += len(rr.Locator) / 2
	return l
}

func (rr *OPENPGPKEY) Len() int {
	l := rr.Hdr.Len()
	l += base64.StdEncoding.DecodedLen(len(rr.PublicKey))
	return l
}

func (rr *ZONEMD) Len() int {
	l := rr.Hdr.Len()
	l += 4 // Serial
	l++    // Scheme
	l++    // Hash
	l += len(rr.Digest) / 2
	return l
}

func (rr *APL) Len() int {
	l := rr.Hdr.Len()
	for _, x := range rr.Prefixes {
		l += x.len()
	}
	return l
}
